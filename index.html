<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zjvoltis - The Quest for the Holy Grape</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #2c3e50;
            color: white;
        }
        .game-container {
            max-width: 700px;
            margin: 0 auto;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 50px);
            gap: 1px;
            margin: 20px auto;
            background: #34495e;
            padding: 10px;
            border-radius: 5px;
        }
        .board-square {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.2s ease;
            position: relative;
            overflow: visible;  /* Changed from hidden to visible */
        }
        .light { background: #AAFAAA; color: #2c3e50; }
        .dark { background: #87DA87; color: #2c3e50; }
        .center { background: #87EA87 !important; color: white; }
        .selected { background: #e74c3c !important; color: white; }
        .piece-highlight { background: rgba(241, 196, 15, 0.6) !important; }
        
        .piece-svg {
            position: absolute;
            transition: transform 0.3s ease;
            pointer-events: none;
        }
        
        .piece-container {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        .rotation-btn {
            background: #f39c12;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .rotation-btn:hover { background: #e67e22; }
        .rotation-btn:disabled { background: #7f8c8d; cursor: not-allowed; }
        .status { 
            text-align: center; 
            margin: 10px 0; 
            padding: 10px; 
            background: rgba(255,255,255,0.1); 
            border-radius: 5px; 
        }
        .blue-turn { color: #3498db; }
        .red-turn { color: #e74c3c; }
        .instructions {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        /* Fallback styles for when SVGs are not loaded */
        .piece-fallback {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 20px;
        }
        .piece-blue .piece-fallback { 
            background: #3498db; 
            color: white; 
        }
        .piece-red .piece-fallback { 
            background: #e74c3c; 
            color: white; 
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 style="text-align: center; color: #f39c12;">üçá Zjvoltis - The Quest for the Holy Grape üçá</h1>
        
        <div class="instructions">
            <strong>How to play:</strong><br>
            1. Click on one of your pieces to select it<br>
            2. Choose rotation: 1 = 90¬∞ counter-clockwise, 2 = 180¬∞, 3 = 270¬∞ counter-clockwise<br>
            3. Goal: Get your orangutan (O/o) to the center OR capture opponent's orangutan<br>
            4. Draw by threefold repetition or 50 moves without capture
        </div>
        
        <div class="status">
            <div>Player: <span id="current-player" class="blue-turn">Blue</span></div>
            <div id="game-status"></div>
        </div>

        <div id="message" class="status">Click on a piece to select it</div>

        <div class="game-board" id="game-board">
            <!-- Board will be generated by JavaScript -->
        </div>

        <div class="controls" id="rotation-controls" style="display: none;">
            <p>Choose rotation:</p>
            <button class="rotation-btn" onclick="makeMove(1)">1 (90¬∞ counter-clockwise)</button>
            <button class="rotation-btn" onclick="makeMove(2)">2 (180¬∞)</button>
            <button class="rotation-btn" onclick="makeMove(3)">3 (270¬∞ counter-clockwise)</button>
            <button class="rotation-btn" onclick="cancelSelection()" style="background: #7f8c8d;">Cancel</button>
        </div>

        <div style="text-align: center;">
            <button class="rotation-btn" onclick="newGame()" style="background: #27ae60;">New Game</button>
        </div>
    </div>

    <script>
        // Game constants
        const EMPTY = 0;
        const BLUE = 0;
        const RED = 1;

        // Piece types
        const ZEBRA_P = 2;
        const JAGUAR_P = 4;
        const VAMPIRE_P = 6;
        const ORANGUTAN_P = 8;
        const LEOPARD_P = 10;
        const TIGER_P = 12;
        const INSECT_P = 14;
        const SEAHORSE_P = 16;

        const PIECE_CHARS = {
            'Z': BLUE | ZEBRA_P, 'J': BLUE | JAGUAR_P, 'V': BLUE | VAMPIRE_P,
            'O': BLUE | ORANGUTAN_P, 'L': BLUE | LEOPARD_P, 'T': BLUE | TIGER_P,
            'I': BLUE | INSECT_P, 'S': BLUE | SEAHORSE_P,
            'z': RED | ZEBRA_P, 'j': RED | JAGUAR_P, 'v': RED | VAMPIRE_P,
            'o': RED | ORANGUTAN_P, 'l': RED | LEOPARD_P, 't': RED | TIGER_P,
            'i': RED | INSECT_P, 's': RED | SEAHORSE_P,
        };

        const VALUE_TO_CHAR = {};
        for (const [char, value] of Object.entries(PIECE_CHARS)) {
            VALUE_TO_CHAR[value] = char;
        }
        VALUE_TO_CHAR[EMPTY] = '.';

        // Map piece types to animal names for SVG files
        const PIECE_TYPE_TO_ANIMAL = {
            [ZEBRA_P]: 'zebra',
            [JAGUAR_P]: 'jaguar',
            [VAMPIRE_P]: 'vampire',
            [ORANGUTAN_P]: 'orangutan',
            [LEOPARD_P]: 'leopard',
            [TIGER_P]: 'tiger',
            [INSECT_P]: 'insect',
            [SEAHORSE_P]: 'seahorse'
        };

        // Track rotation for each piece (by first square coordinates)
        const pieceRotations = new Map();

        function isBlue(piece) {
            return piece !== EMPTY && piece % 2 === BLUE;
        }

        function getPieceType(piece) {
            return piece & 0b11111110;
        }

        // Game state
        let game = {
            board: Array(10).fill(null).map(() => Array(10).fill(EMPTY)),
            blue_to_move: true,
            game_over: null,
            history: [],
            moves_since_capture: 0
        };

        let selectedSquare = null;
        let selectedPieceCoords = [];

        // Initialize game from FEN
        function initFromFen(fen) {
            const parts = fen.split(' ');
            const boardStr = parts[0];
            
            game.board = Array(10).fill(null).map(() => Array(10).fill(EMPTY));
            
            let currentRow = 9, currentCol = 0;
            for (const char of boardStr) {
                if (char >= '0' && char <= '9') {
                    currentCol += parseInt(char);
                } else if (char === 'A') {
                    currentCol += 10;
                } else if (char === '/') {
                    currentRow--;
                    currentCol = 0;
                } else if (char === '.') {
                    currentCol++;
                } else if (PIECE_CHARS[char]) {
                    if (currentRow >= 0 && currentRow < 10 && currentCol >= 0 && currentCol < 10) {
                        game.board[currentRow][currentCol] = PIECE_CHARS[char];
                    }
                    currentCol++;
                }
            }
            
            if (parts.length > 1) {
                game.blue_to_move = parts[1] === 'w';
            }
        }

        // Get piece identifier for rotation tracking
        function getPieceIdentifier(row, col) {
            const piece = game.board[row][col];
            if (piece === EMPTY) return null;
            
            // Find the topmost, leftmost square of this piece
            const allCoords = findAllSquaresOfPiece(row, col);
            if (allCoords.length === 0) return null;
            
            // Sort to find top-left square
            allCoords.sort((a, b) => {
                if (a[0] !== b[0]) return b[0] - a[0]; // Higher row first
                return a[1] - b[1]; // Lower column first
            });
            
            return `${allCoords[0][0]},${allCoords[0][1]}`;
        }

        // Rotation function
        function rotatePoint(r, c, centerR, centerC) {
            const translatedR = r - centerR;
            const translatedC = c - centerC;
            const rotatedC = -translatedR;
            const rotatedR = translatedC;
            return [centerR + rotatedR, centerC + rotatedC];
        }

        // Find diamond around square
        function diamondAroundSquare(rCenter, cCenter, includeSelf) {
            const squares = [];
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (i + j < 4) {
                        if (i === 0 && j === 0 && !includeSelf) continue;
                        
                        const positions = [
                            [rCenter + i, cCenter + j],
                            [rCenter + i, cCenter - j],
                            [rCenter - i, cCenter + j],
                            [rCenter - i, cCenter - j]
                        ];
                        
                        for (const [r, c] of positions) {
                            if (r >= 0 && r < 10 && c >= 0 && c < 10) {
                                if (!(i === 0 && j === 0) || includeSelf) {
                                    squares.push([r, c]);
                                }
                            }
                        }
                    }
                }
            }
            return [...new Set(squares.map(s => s.join(',')))].map(s => s.split(',').map(Number));
        }

        // Find all squares of piece
        function findAllSquaresOfPiece(pivotR, pivotC) {
            const targetPiece = game.board[pivotR][pivotC];
            if (targetPiece === EMPTY) return [];
            
            const candidates = diamondAroundSquare(pivotR, pivotC, true);
            const coords = [];
            
            for (const [r, c] of candidates) {
                if (r >= 0 && r < 10 && c >= 0 && c < 10) {
                    if (game.board[r][c] === targetPiece) {
                        coords.push([r, c]);
                    }
                }
            }
            return coords;
        }

        // Make move
        function attemptMove(pivotR, pivotC, hgrad) {
            if (pivotR < 0 || pivotR >= 10 || pivotC < 0 || pivotC >= 10) return false;
            if (hgrad < 1 || hgrad > 3) return false;
            
            const pieceToMove = game.board[pivotR][pivotC];
            if (pieceToMove === EMPTY) return false;
            if (game.blue_to_move !== isBlue(pieceToMove)) return false;
            
            const allOriginalCoords = findAllSquaresOfPiece(pivotR, pivotC);
            if (allOriginalCoords.length === 0) return false;
            
            // Get current rotation before move
            const pieceId = getPieceIdentifier(pivotR, pivotC);
            const currentRotation = pieceRotations.get(pieceId) || 0;
            
            const otherPartsCoords = allOriginalCoords.filter(([r, c]) => !(r === pivotR && c === pivotC));
            
            const newOtherPartsCoords = [];
            for (const [rPart, cPart] of otherPartsCoords) {
                let [currentR, currentC] = [rPart, cPart];
                for (let i = 0; i < hgrad; i++) {
                    [currentR, currentC] = rotatePoint(currentR, currentC, pivotR, pivotC);
                }
                newOtherPartsCoords.push([Math.round(currentR), Math.round(currentC)]);
            }
            
            // Validate new positions
            for (const [rNew, cNew] of newOtherPartsCoords) {
                if (rNew < 0 || rNew >= 10 || cNew < 0 || cNew >= 10) return false;
                
                const pieceAtTarget = game.board[rNew][cNew];
                if (pieceAtTarget !== EMPTY && isBlue(pieceAtTarget) === game.blue_to_move) {
                    const inOriginal = allOriginalCoords.some(([r, c]) => r === rNew && c === cNew);
                    if (!inOriginal) return false;
                }
            }
            
            // Handle captures
            const capturedEnemyCoords = new Set();
            let orangutanCaptured = false;
            
            for (const [rNew, cNew] of newOtherPartsCoords) {
                const pieceAtDest = game.board[rNew][cNew];
                if (pieceAtDest !== EMPTY && isBlue(pieceAtDest) !== game.blue_to_move) {
                    if (getPieceType(pieceAtDest) === ORANGUTAN_P) {
                        orangutanCaptured = true;
                    }
                    const enemyCoords = findAllSquaresOfPiece(rNew, cNew);
                    for (const coord of enemyCoords) {
                        capturedEnemyCoords.add(coord.join(','));
                    }
                }
            }
            
            // Remove rotation data for captured pieces
            for (const coordStr of capturedEnemyCoords) {
                const [r, c] = coordStr.split(',').map(Number);
                const capturedPieceId = getPieceIdentifier(r, c);
                if (capturedPieceId) {
                    pieceRotations.delete(capturedPieceId);
                }
            }
            
            // Remove captured pieces
            for (const coordStr of capturedEnemyCoords) {
                const [r, c] = coordStr.split(',').map(Number);
                game.board[r][c] = EMPTY;
            }
            
            // Clear old positions (except those staying in place)
            for (const [rOld, cOld] of otherPartsCoords) {
                const staysInPlace = newOtherPartsCoords.some(([r, c]) => r === rOld && c === cOld);
                if (!staysInPlace) {
                    game.board[rOld][cOld] = EMPTY;
                }
            }
            
            // Place in new positions
            for (const [rNew, cNew] of newOtherPartsCoords) {
                game.board[rNew][cNew] = pieceToMove;
            }
            
            // Update rotation for this piece
            const newPieceId = getPieceIdentifier(pivotR, pivotC);
            if (newPieceId) {
                const newRotation = (currentRotation - hgrad * 90) % 360;
                pieceRotations.set(newPieceId, newRotation);
            }
            
            // Check win conditions
            if (orangutanCaptured) {
                game.game_over = game.blue_to_move ? 1 : -1;
            } else if (getPieceType(pieceToMove) === ORANGUTAN_P) {
                // Check center win
                const centerSquares = [[4,4], [5,5]];
                let orangutanInCenter = true;
                for (const [cR, cC] of centerSquares) {
                    if (game.board[cR][cC] !== pieceToMove) {
                        orangutanInCenter = false;
                        break;
                    }
                }
                if (orangutanInCenter) {
                    game.game_over = game.blue_to_move ? 1 : -1;
                }
            }
            
            // Update counters
            if (capturedEnemyCoords.size > 0) {
                game.moves_since_capture = 0;
            } else {
                game.moves_since_capture++;
            }
            
            // Check draw conditions
            if (game.moves_since_capture >= 100) {
                game.game_over = 0;
            }
            
            // Simple position tracking for repetition
            const positionKey = game.board.flat().join('') + (game.blue_to_move ? 'w' : 'b');
            game.history.push(positionKey);
            
            const positionCount = game.history.filter(pos => pos === positionKey).length;
            if (positionCount >= 3) {
                game.game_over = 0;
            }
            
            // Switch turns
            game.blue_to_move = !game.blue_to_move;
            return true;
        }

        // Create SVG element for piece
        function createPieceSVG(piece, row, col, allCoords, topLeftRow, topLeftCol) {
			
			const color = isBlue(piece) ? 'blue' : 'red';
            const pieceType = getPieceType(piece);
            const animal = PIECE_TYPE_TO_ANIMAL[pieceType];
            
            if (!animal) return null;
            
            // Get rotation for this piece
            const pieceId = getPieceIdentifier(row, col);
            const rotation = pieceRotations.get(pieceId) || 0;
			if (rotation !== 0) {
				//showMessage(`Debug - piece: ${VALUE_TO_CHAR[piece]}, rot: ${rotation}, row: ${row}, col: ${col}, topLeftRow: ${topLeftRow}, topLeftCol: ${topLeftCol}, allCoords: [${allCoords.map(c => `(${c[0]},${c[1]})`).join(', ')}]`);
			
			}
			// Find bounds of the piece
            let minRow = 10, maxRow = -1, minCol = 10, maxCol = -1;
			
            for (const [r, c] of allCoords) {
                minRow = Math.min(minRow, r);
                maxRow = Math.max(maxRow, r);
                minCol = Math.min(minCol, c);
                maxCol = Math.max(maxCol, c);
            }
            
            // Calculate size with paddinglet numCols, numRows;
			if (rotation % 180 === 0) {
				// 0 or 180 degrees - use normal orientation
				numCols = maxCol - minCol + 1;
				numRows = maxRow - minRow + 1;
			} else {
				// 90 or 270 degrees - swap dimensions
				numCols = maxRow - minRow + 1;
				numRows = maxCol - minCol + 1;
				
			}
            const totalWidth = numCols * 50 - 10; // 5px padding on each side
            const totalHeight = numRows * 50 - 10; // 5px padding on each side
            
            
            const img = document.createElement('img');
            img.className = 'piece-svg';
            img.src = `${color}_${animal}.svg`;
            img.alt = `${color} ${animal}`;
            img.style.width = '100%';
            img.style.height = '100%';
			if (rotation % 180 === 0 || piece === 6 || piece === 7 || piece === 8 || piece === 9) {
				// 0 or 180 degrees or vampire or orangutan
				img.style.transformOrigin = '50% 50%'; // Centrerad rotation
			} else if (piece === 14 || piece === 15) {
				// insect
				if (rotation === -90) {
					img.style.transformOrigin = '95px 95px';
				} else {	
					img.style.transformOrigin = '20px 20px';
				}
				//if (rotation === 1) { piece === 6 || 
			} else if (piece === 16 || piece === 17 || piece === 2 || piece === 3) {
				if (totalWidth < totalHeight) {
					img.style.transformOrigin = '50% 33%';
				} else {
					img.style.transformOrigin = '70px 70px';
				}
			} else {
				if (rotation === -90) {
					img.style.transformOrigin = '70px 70px';
				} else {
					img.style.transformOrigin = '44px 45px';
				}
			}
            if (rotation !== 0) {
                img.style.transform = `rotate(${rotation}deg)`;
            }	
            
            // Create container for the SVG
            const container = document.createElement('div');
            container.className = 'piece-container';
            container.style.width = totalWidth + 'px';
            container.style.height = totalHeight + 'px';
            
            // Position with 5px offset for padding
            const offsetLeft = (minCol - topLeftCol) * 50 + 5;
            const offsetTop = (maxRow - topLeftRow) * 50 + 5;
            container.style.left = offsetLeft + 'px';
            container.style.top = offsetTop + 'px';
            // Fallback in case SVG doesn't load
            img.onerror = function() {
                // Create fallback with letters for all squares
                container.innerHTML = '';
                container.style.display = 'none';
                
                // Add letters back to the original squares
                const pieceChar = VALUE_TO_CHAR[piece];
                for (const [r, c] of allCoords) {
                    const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (square && !square.querySelector('.piece-fallback')) {
                        const fallback = document.createElement('div');
                        fallback.className = 'piece-fallback';
                        fallback.textContent = pieceChar;
                        fallback.classList.add(isBlue(piece) ? 'piece-blue' : 'piece-red');
                        fallback.style.width = '100%';
                        fallback.style.height = '100%';
                        square.appendChild(fallback);
                    }
                }
            };
            
            container.appendChild(img);
            return container;
        }

        // UI Functions
        function initBoard() {
            const board = document.getElementById('game-board');
            board.innerHTML = '';
            
            // Track which pieces we've already rendered
            const renderedPieces = new Set();
            
            for (let r = 9; r >= 0; r--) {
                for (let c = 0; c < 10; c++) {
                    const square = document.createElement('div');
                    square.className = 'board-square';
                    square.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    
                    if ((r === 4 || r === 5) && (c === 4 || c === 5)) {
                        square.classList.add('center');
                    }
                    
                    square.dataset.row = r;
                    square.dataset.col = c;
                    square.onclick = () => selectSquare(r, c);
                    
                    const piece = game.board[r][c];
                    if (piece !== EMPTY) {
                        const pieceId = getPieceIdentifier(r, c);
                        
                        // Only render the SVG once per piece (on the top-left square)
                        if (pieceId && !renderedPieces.has(pieceId)) {
                            const allCoords = findAllSquaresOfPiece(r, c);
                            
                            // Find the top-left square of this piece
                            let topLeftRow = r, topLeftCol = c;
                            for (const [pr, pc] of allCoords) {
                                if (pr > topLeftRow || (pr === topLeftRow && pc < topLeftCol)) {
                                    topLeftRow = pr;
                                    topLeftCol = pc;
                                }
                            }
                            
                            // Only create SVG if this is the top-left square
                            if (r === topLeftRow && c === topLeftCol) {
                                const svgElement = createPieceSVG(piece, r, c, allCoords, topLeftRow, topLeftCol);
                                if (svgElement) {
                                    square.appendChild(svgElement);
                                    renderedPieces.add(pieceId);
                                }
                            }
                        }
                    }
                    
                    board.appendChild(square);
                }
            }
            updateDisplay();
        }

        function updateDisplay() {
            const currentPlayer = document.getElementById('current-player');
            currentPlayer.textContent = game.blue_to_move ? 'Blue' : 'Red';
            currentPlayer.className = game.blue_to_move ? 'blue-turn' : 'red-turn';
            
            const gameStatus = document.getElementById('game-status');
            if (game.game_over !== null) {
                if (game.game_over === 1) {
                    gameStatus.textContent = 'Blue wins!';
                    gameStatus.style.color = '#27ae60';
                } else if (game.game_over === -1) {
                    gameStatus.textContent = 'Red wins!';
                    gameStatus.style.color = '#27ae60';
                } else {
                    gameStatus.textContent = 'Draw!';
                    gameStatus.style.color = '#f39c12';
                }
            } else {
                gameStatus.textContent = '';
            }
        }

        function selectSquare(row, col) {
            if (game.game_over !== null) {
                showMessage('Game is over!');
                return;
            }
            
            const piece = game.board[row][col];
            if (piece === EMPTY) {
                showMessage('No piece on that square');
                return;
            }
            
            if (game.blue_to_move !== isBlue(piece)) {
                showMessage('You can only select your own pieces!');
                return;
            }
            
            // Clear previous selection
            document.querySelectorAll('.board-square').forEach(sq => {
                sq.classList.remove('selected', 'piece-highlight');
            });
            
            selectedSquare = { row, col };
            selectedPieceCoords = findAllSquaresOfPiece(row, col);
            
            // Highlight piece
            for (const [r, c] of selectedPieceCoords) {
                const square = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                if (square) {
                    square.classList.add('piece-highlight');
                }
            }
            
            const pivotSquare = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (pivotSquare) {
                pivotSquare.classList.add('selected');
            }
            
            document.getElementById('rotation-controls').style.display = 'block';
            const pieceType = getPieceType(piece);
            const animal = PIECE_TYPE_TO_ANIMAL[pieceType];
            showMessage(`Selected: ${animal} at ${String.fromCharCode(97 + col)}${row}. Choose rotation.`);
        }

        function cancelSelection() {
            selectedSquare = null;
            selectedPieceCoords = [];
            document.querySelectorAll('.board-square').forEach(sq => {
                sq.classList.remove('selected', 'piece-highlight');
            });
            document.getElementById('rotation-controls').style.display = 'none';
            showMessage('Click on a piece to select it');
        }

        function makeMove(rotation) {
            if (!selectedSquare) {
                showMessage('No piece selected!');
                return;
            }
            
            if (game.game_over !== null) {
                showMessage('Game is over!');
                return;
            }
            
            const success = attemptMove(selectedSquare.row, selectedSquare.col, rotation);
            if (success) {
                cancelSelection();
                initBoard();
                if (game.game_over !== null) {
                    showMessage('Game is over!');
                } else {
                    showMessage('Move completed!');
                }
            } else {
                showMessage('Invalid move!');
            }
        }

        function newGame() {
            game = {
                board: Array(10).fill(null).map(() => Array(10).fill(EMPTY)),
                blue_to_move: true,
                game_over: null,
                history: [],
                moves_since_capture: 0
            };
            
            // Clear all rotations
            pieceRotations.clear();
            
            initFromFen("liiiitttoo/lzzvvstjoo/llzzvssjjj/......s...///...S....../JJJSSVZZLL/OOJTSVVZZL/OOTTTIIIIL w");
            
            //initFromFen("........../........../.IIII...../..........///.iiii...../..........// w");
            cancelSelection();
            initBoard();
            showMessage('New game started!');
        }

        function showMessage(message) {
            document.getElementById('message').textContent = message;
        }

        // Keyboard support
        document.addEventListener('keydown', function(event) {
            if (selectedSquare) {
                if (event.key === '1') makeMove(1);
                else if (event.key === '2') makeMove(2);
                else if (event.key === '3') makeMove(3);
                else if (event.key === 'Escape') cancelSelection();
            }
        });

        // Start game
        newGame();
    </script>
</body>
</html>